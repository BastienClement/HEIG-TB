\section{Spécifications}

\subsection{Définition}
Un \texttt{Signal[T]} représente une information de type \texttt{T} dont la disponibilité ou la valeur peut varier avec le temps. À tout moment, il peut se trouver dans l'un des deux états suivants:
\begin{enumerate}
	\item \texttt{Undefined}: le signal ne possède pas de valeur définie,
	\item \texttt{Defined(value)}: le signal possède actuellement la valeur \texttt{value}
\end{enumerate}

Il peut être vu comme une extension de \texttt{Future[T]}. De façon similaire, il représente la présence ou l'absence d'information au fil du temps, mais à la différence de \texttt{Future}, il est autorisé à changer d'état un nombre arbitraire de fois tandis que l'état d'un \texttt{Future} est figé une fois celui-ci résolu.

Le type \texttt{Signal[T]} est covariant avec son paramètre \texttt{T}. L'interface exposée ne permettant que l'accès à la valeur du signal ou sa transformation par le biais de la construction d'un nouveau signal, une instance \texttt{Signal[B]} est substituable à \texttt{Signal[A]} si \texttt{B <: A}\footnote{\texttt{B <: A} désigne une relation de sous-type (\texttt{B extends A})}.

L'état d'un signal peut être dépendant de l'état d'un ou plusieurs autres signaux. Il constitue alors un signal \emph{enfant} associé à un ensemble de signaux \emph{parents}. Cet ensemble peut varier dynamiquement au fil du temps. Un signal enfant ne peut changer d'état que lorsque au moins l'un des ses signaux parents change d'état.

À l'inverse, un signal qui ne dépend d'aucun autre est appelé une \emph{source}. Le changement d'état d'un signal source ne peut s'opérer que par une mutation explicite, extérieur au système de signaux.

\texttt{Signal} vérifie les trois axiomes des monades \cite{haskell-monad-laws}:
\begin{align*}
Signal(x) \text{ flatMap } f &\equiv f(x) \\
a \text{ flatMap } (x \mapsto Signal(x)) &\equiv a \\
(a \text{ flatMap } f)  \text{ flatMap } g &\equiv
a \text{ flatMap } (x \mapsto f(x)  \text{ flatMap } g) 
\end{align*}
Ici, l'opérateur $\equiv$ désigne une équivalence structurelle: les deux expressions sont substituables sans affecter le comportement du programme.

\subsection{Accès à l'état courant}
L'interface d'un signal \texttt{Signal[T]} défini deux méthodes pour accéder à sa valeur courante:
\begin{enumerate}
	\item \textbf{\texttt{Signal.option}}: retourne la valeur courante d'un signal sous la forme d'une \texttt{Option[T]}. C'est une façon sûre d'accéder à l'état du signal quel qu'il soit.
	
	\item \textbf{\texttt{Signal.value}}: retourne la valeur courante du signal (donc une valeur de type \texttt{T}) s'il est défini ou lance une exception\footnote{De type \texttt{UndefinedSignalException}} s'il ne l'est pas. De façon générale, cette méthode est plutôt destinée à être utilisée dans le cadre de la définition de signaux expression (section \ref{sec:sig-expr}) puisque dans ce cas, l'exception est traitée par le constructeur et entraîne la construction d'un signal vide.
\end{enumerate}

Dans le cas où il est nécessaire d'être informé des futurs changements d'états du signal, le mécanisme d'observateur (§~\ref{sec:sig-obs}) peut être utilisé.

\subsection{Pureté et modes d'évaluation} \label{sec:sig-pureness}
Un signal est considéré comme une construction fonctionnelle semi-pure: il n'est dépendant d'aucun état global à l'exception d'autres signaux et ne présente pas d'effets de bords. Ces contraintes s'étendent également aux fonctions utilisées dans leur définition ou transformation par le biais de méthodes telles que \texttt{map} ou \texttt{filter}. Le langage Scala ne permettant pas d'imposer la notion de pureté aux fonction, il est de la responsabilité du développeur de s'assurer que cette contrainte soit respectée.

Cette contrainte découle principalement de l'existence de deux modes d'évaluations pour les signaux qui définissent à quel moment l'état d'un signal enfant doit être calculé après le changement d'état d'un de ses signaux parent:

\begin{enumerate}
	\item \emph{Paresseux}: l'état du signal enfant est réévalué à la demande, lorsque son état courant est accédé et après un changement d'état d'au moins un des ses signaux parents,
	\item \emph{Différé}: l'état du signal enfant est réévalué à la fermeture d'un contexte de mutation impliquant la modification d'au moins un signal parent.
\end{enumerate}

Le mode d'évaluation paresseux est le mode utilisé par défaut pour les signaux. Il offre l'avantage de réduire le nombre d'états à calculer dans le cas où un signal n'est pas accédé aussi fréquemment que son état ne change. Il n'offre cependant aucune garantie concernant le moment auquel une fonction utilisée comme définition d'un signal ou d'une transformation sera appelée, ni même qu'elle sera un jour appelée. Il est donc particulièrement important que ces fonctions respectent également la contrainte de pureté des signaux pour ne pas introduire des comportements non-déterministes dans l'application.

Le mode différé n'est utilisé que dans les situations où l'événement de changement d'état est significatif en plus de la valeur de ce nouvel état. C'est par exemple le cas de l'opération \texttt{fold} (§ \ref{sec:sig-op-fold}) qui est utilisée pour combiner les états successifs d'un signal parent afin de construire l'état du signal enfant. Dans une telle situation, l'utilisation du mode paresseux rendrait le signal enfant non-déterministe puisque son état serait dépendant de la fréquence à laquelle il est accédé \footnote{Si la fréquence d'accès est inférieure à la fréquence de changement d'état du signal parent, certains états seront \emph{manqués} par l'opération de combinaison.}.

Par ailleurs, entre les changements d'états d'un signal parent, l'état d'un signal enfant est gardé en mémoire. L'objectif est d'éviter de devoir recalculer l'ensemble d'une hiérarchie de signaux à chaque accès d'un signal enfant. La valeur d'un signal enfant n'étant pas sensé changer sans un changement d'état d'un parent.

En résumé, l'usage combiné de la \emph{memoization} et de l'évaluation paresseuse rend le timing d'évaluation des fonctions utilisées pour la définition et la transformation de signaux imprévisible, d'autant plus lorsque l'application et la structure de graphe de signaux se complexifie. Respecter la contrainte de pureté lors de l'utilisation des signaux permet de s'affranchir de cette complexité et de se concentrer sur la logique métier de l'application développée.

\subsection{Hiérarchie simplifiée}
La figure \ref{fig:sig-simple-hierarchy} présente une version simplifiée de la hiérarchie des signaux. Seules les informations pertinentes à l'utilisation des signaux ont été conservée: les méthodes, interfaces, classes intermédiaires relevant des détails d'implémentation ne sont pas incluses. La hiérarchie complète formée par les signaux est présentée en section \ref{sec:sig-hierarchy}.

\begin{figure}[!h]
	\centering
	\includegraphics[width=12cm]{img/signals_simple}
	\caption{Hiérarchie simplifiée des signaux}
	\label{fig:sig-simple-hierarchy}	
\end{figure}

Le trait racine \texttt{Signal} est l'interface générique destinée à être manipulée par le développeur, quelque soit le type concret de signal manipulé. Il expose les méthodes nécessaires à l'accès à l'état courant du signal ainsi qu'à la construction de signaux dérivés par transformation. C'est une interface immutable qui ne permet de modifier l'état courant du signal.

La séparation des signaux en deux sous-arbres, \texttt{Mutable} et \texttt{Immutable}, capture les différences sémantiques liées à la présence ou l'absence d'une garantie d'immutabilité de l'état d'un signal.

L'intérêt d'un signal dont la valeur ne varie pas peut sembler limité à priori mais se révèle lorsqu'une valeur non-signal doit être encapsulée dans un signal afin de satisfaire le système de types. Un tel signal n'a pas de raison de changer d'état au fil du temps, il est alors effectivement immutable. La présence de cette contrainte de façon explicite au niveau de la hiérarchie permet la mise en place d'un certain nombre d'optimisations.

Une instance de la classe \texttt{Constant[T]} est simplement une valeur de type \texttt{T} avec une interface de signal. Un tel signal est toujours dans l'état \emph{défini}.

L'objet singleton \texttt{Undefined} représente quant à lui le signal dont l'état est toujours \emph{indéfini}. Il est généralement référencé à partir de l'objet compagnon du trait \texttt{Signal}: sous la forme \texttt{Signal.undefined}. Puisqu'il n'est jamais défini, il est déclaré comme une instance de \texttt{Signal[Nothing]}. Il est ainsi, par covariance, substituable à n'importe quel type de signal \texttt{Signal[T]} \footnote{\texttt{Nothing} est le \emph{bottom type} du système de types en Scala, il est sous-type de tous les types ($\forall \texttt{T}, \texttt{Nothing <: T}$) mais il n'en existe aucune instance.}.

Un signal immutable ne peut être ni \emph{enfant} ni \emph{parent} d'autres signaux. Comme ils ne changent jamais, il n'y a pas de sens de maintenir de graphe de dépendances entre eux. Il n'y aura en effet jamais de propagation de changement d'état à effectuer.

Les deux types de signaux mutables, sources (§ \ref{sec:sig-source}) et expressions (§ \ref{sec:sig-expr}), sont décrits plus en détails dans les sections les concernant.

\subsection{Construction}
Un signal est généralement dérivé par transformation de signaux existants. Cependant, dans le cas où un nouveau signal racine doit être construit, deux approches sont disponibles.

La première méthode est l'utilisation des constructeurs offerts par l'objet compagnon du trait \texttt{Signal}:

\begin{itemize}
	\item \code{def Signal.apply[T](expr: => T): Signal[T]}
	\item \code{def Signal.define[T](expr: => Option[T]): Signal[T]}
\end{itemize}

L'expression fournie à \texttt{apply} sera évaluée pour déterminer la valeur du signal produit et les dépendances vers d'autres signaux seront automatiquement identifiées. Si l'expression fait référence à l'état d'au moins un signal parent non-constant, un signal de type \texttt{Expression} (§ \ref{sec:sig-expr}) est retourné. Dans le cas où aucun signal parent n'a été accédé, un signal de type \texttt{Constant} est retourné.

La variante \texttt{define} est similaire mais considère une valeur \texttt{None} comme un signal indéfini tandis qu'une valeur \texttt{Some(v)} est considérée comme un signal défini et de valeur \texttt{v}. 

S'il n'est pas souhaitable que l'expression de définition soit évaluée immédiatement, il est possible de différé son évaluation au premier accès à l'état du signal produit en utilisant le constructeur
\begin{center}
	\code{def Signal.defer[T](expr: => T): Signal[T]}
\end{center}
Le signal ainsi produit sera de type \texttt{Expression[T]}, même si l'expression passée ne fait référence à aucun autre signal, formant alors un signal expression effectivement constant.

Les méthodes \texttt{apply}, \texttt{define} et \texttt{defer} prennent en réalité des paramètres optionnels supplémentaires permettant de configurer la sémantique du signal défini. La signature complète de ces méthodes est disponible dans la Scaladoc du projet.

La secondes approche consiste en la construction explicite d'un signal de type \texttt{Source} (§ \ref{sec:sig-source}). 

\subsection{Signal source} \label{sec:sig-source}

Une \texttt{Source[T]} est l'équivalent réactif d'une variable en programmation non-réactive. C'est un conteneur mutable pour une valeur de type \texttt{T}, pouvant être indéfinie. Deux constructeurs sont disponibles selon l'état initial désiré pour la source:

\begin{itemize}
	\item \code{def Source.apply[T](value: T): Source[T]}
	\item \code{def Source.undefined[T]: Source[T]}
\end{itemize}

Une instance de \texttt{Source[T]} offre une méthode de mutation explicite
\begin{center}
	\code{def := (value: T): Unit}
\end{center}
permettant de mettre à jour la valeur contenue dans la source de façon impérative. Cette opération est un changement d'état de la source et provoquera l'invalidation récursive des tous les signaux en dépendant.

Une source est destinée à être utilisées lors de la construction de système hybrides, combinant code impératif basé sur les effets de bords et code fonctionnel. La source est alors un point d'entrée dans le graphe de dépendances des signaux pour la partie de code impérative.

Une surcharge de l'opérateur de mutation
\begin{center}
	\code{def := (nil: Signal.nil.type): Unit}
\end{center}
permet de définir explicitement l'état indéfini pour la source. Cette surcharge est invoquée en passant explicitement l'objet \texttt{Signal.nil} en tant qu'opérande de droite à l'opérateur \texttt{:=}.

Finalement, si la nouvelle valeur d'une source est dérivée de sa valeur actuelle, l'opérateur de mise à jour
\begin{center}
	\code{def ~= (f: T => T): Unit}
\end{center}
permet de fournir une fonction qui sera invoquée avec la valeur courante de la source et dont la valeur de retour sera utilisée comme nouvelle valeur de la source. Si la source est actuellement indéfinie, l'opérateur n'a aucun effet et la fonction n'est pas invoquée.

Cet opérateur est plus qu'un simple sucre syntaxique par rapport à l'usage explicite des méthodes \texttt{option} et \texttt{value}. Dans le contexte des observateurs (§~\ref{sec:sig-obs}), accéder à la valeur d'une source (de même que n'importe quel type de signal mutable) établi une dépendance entre le signal et l'observateur. L'observateur est donc invoqué à chaque changement de la source et son implémentation consiste à la mutation de cette même source, établissant ainsi une boucle infinie.

À l'inverse, l'opérateur \code{~=} ne construit pas de dépendance entre la source et l'observateur. Il est bien entendu de la responsabilité du développeur de s'assurer de ne pas \emph{leak} la valeur précédente ou courante de cette source hors de la fonction de mutation.

\subsection{Signal expression} \label{sec:sig-expr}

Un signal expression est un signal dont la définition est une expression arbitraire. Un tel signal détermine automatiquement ses signaux parents en observant les signaux accédés lors de l'évaluation de l'expression et construit ainsi automatiquement son arbre de dépendances. Si l'un de ces signaux venait à changer, la valeur du signal expression serait recalculée.

Il est construit en passant l'expression de définition au constructeur \texttt{Signal} tel qu'illustré par la figure \ref{fig:signal-expr-init}. La variante \texttt{Signal.define} est similaire à la méthode \texttt{apply}, mais reçoit une expression de type \texttt{Option[T]}. Une évaluation de cette expression produisant la valeur \texttt{None} ou une instance \texttt{Some(v)} conduit respectivement à un état indéfini ou défini du signal.

\begin{figure}[!h]
	\begin{lstlisting}
val a: Signal[Int] = ...
val b: Signal[Int] = ...
val c: Signal[Int] = Signal {
	a.value + b.value
}
	\end{lstlisting}
	\caption{Déclaration d'un signal expression}
	\label{fig:signal-expr-init}
\end{figure}

Les parents d'un signal expression sont dynamiques. À chaque évaluation, la liste des parents est vidée puis reconstruite selon l'évaluation actuelle. De cette façon, les dépendances sont toujours les plus précises possible et les invalidations inutiles sont évitées. Ceci est particulièrement important dans le cas de signaux contenant des branches et donc un ensemble de dépendances dynamiques selon l'état d'autres signaux.

Dans l'exemple de la figure \ref{fig:signal-expr-branches}, le signal construit ne dépend de \texttt{b} que si la valeur du signal \texttt{a} est \texttt{false}. Dans le cas contraire, il est dépendant de \texttt{c}. Dans tous les cas, une dépendance est créée vers le signal \texttt{a}.

\begin{figure}[!h]
	\begin{lstlisting}
Signal {
	if (a.value) b.value else c.value
}
	\end{lstlisting}
	\caption{Définition d'un signal expression avec branches}
	\label{fig:signal-expr-branches}
\end{figure}

Selon la situation, l'usage d'une expression pour définir un signal peut se révéler plus simple que la combinaison de nombreuses opérations de transformations élémentaires pour composer le comportement attendu.

Dans les cas les plus complexes, principalement lors de l'utilisation de structures de contrôles tel que des branches conditionnelles, des opérations de \emph{pattern matching} ou des boucles, une expression permet une définition concise et atomique du signal tandis que pour obtenir un résultat équivalent à l'aide des opérateurs de transformation, une longue chaîne de transformations successives, considérablement plus difficile à comprendre, serait nécessaire.

À l'inverse, dans les cas plus simples, une opération de transformation permet de réutiliser un \emph{pattern} de transformation établi, étant alors à la fois plus concis et mentalement plus simple puisqu'il utilise une sémantique clairement établie et commune.

\subsubsection{Contraintes des expressions}

Les signaux doivent être considérés comme des constructions semi-pure d'un point de vue fonctionnel (§~\ref{sec:sig-pureness}). Il est ainsi important que l'expression utilisée comme définition respecte ce principe en ne provoquant aucun effet de bord et en ne dépendant d'aucune valeur mutable qui ne serait pas un signal. En effet, si une valeur mutable non-signal est référencée par une expression, l'état résultant du signal est alors dépendant de l'instant d'évaluation pour lequel aucune garantie n'est fournie.

Il est aussi important que l'évaluation d'une expression s'effectue de façon synchrone. En effet la liste de dépendances du signal est construite lors de l'évaluation de l'expression. Si un signal parent est accédé de façon asynchrone ou \emph{lazy}, la dépendance ne sera pas identifiée et le signal ne sera pas correctement invalidé en cas de changement d'état de ce signal parent.

Les deux principaux suspects à considérer sont \texttt{Future} et \texttt{Stream}. Le premier pour le délai qu'il introduit dans l'évaluation de sa valeur, le second pour sa sémantique \emph{lazy}.

Il est intéressant de noter que la seule observation du paramètre de type du signal permet d'identifier un potentiel problème. En effet un signal de type \texttt{Signal[Int]} dont la définition impliquerait l'utilisation d'une instance de \texttt{Stream} n'est pas un souci; une fois la valeur finale de type \texttt{Int} produite, l'ensemble des éléments pertinents du flux auront été consommés de façon synchrone. Le principe s'applique de façon similaire à l'opération \texttt{Option.orElse} pour laquelle le paramètre est passé \emph{by name}.

À l'inverse, un signal \texttt{Signal[Stream[Int]]} expose l'instance de \texttt{Stream} utilisée. Dans une telle situation, si le calcul d'un élément du flux requiert l'accès à un autre signal, aucune relation de dépendance ne sera établie. Des types de signaux tels que \texttt{Signal[Stream[A => B]]}, \texttt{Signal[Future[A]]} voir même \texttt{Signal[A => B]} indiquent un risque important ne pas respecter la contrainte de synchronisme.

\subsection{Opérateurs de transformations}
Dans les exemples ci-dessous, les opérations sont supposées appliquées à une instance de type \texttt{Signal[T]}, \texttt{T} faisant ainsi référence au type d'élément contenu dans le signal original. Seules les opérateurs les plus courants et ceux utilisées par le compilateur Scala lors de la compilation d'une compréhension \texttt{for} sont traités ici. La Scaladoc du projet contient une liste exhaustive des opérations disponibles.

Ces transformations sont pour la plupart construites autour du constructeur \texttt{Signal.define}. Leur évaluation est donc immédiate et produit un valeur de retour en fonction des dépendances du signal original et des signaux accédés par la fonction de transformation fournie. Par exemple, invoquer la méthode \texttt{map} sur un signal \texttt{Constant} retournera en principe un signal \texttt{Constant}, sauf si la fonction passée à \texttt{map} fait référence à la valeur d'autres signaux, produisant alors un signal \texttt{Expression} non-constant.

\subsubsection{Opérateur de transformation simple (\texttt{map})}

\begin{itemize}
	\item \code{def map[U](f: T=>U): Signal[U]}
\end{itemize}

La fonction \texttt{map} effectue une opération de transformation simple sur la valeur d'un signal en appliquant la fonction \texttt{f} à la valeur courante du signal et retournant un nouveau signal contenant en tout temps le résultat de cette transformation. En d'autre termes, lorsque l'état du signal original change, la fonction \texttt{f} est réévaluée avec la nouvelle valeur du signal parent et le signal enfant est mis à jour.

Si le signal d'origine est indéfini, la fonction \texttt{f} n'est pas appliquée et le signal enfant prend également l'état indéfini.

\begin{figure}[h]
	\begin{lstlisting}
val a: Signal[Int] = Source(4)
val b: Signal[Double] = a.map(Math.sqrt(_)) // b.value -> 2.0
a := 9 // b.value -> 3.0

val c: Signal[_] = Signal.undefined // `c` est indéfini
val d: Signal[_] = c.map(value => ???)
d.option == None // la fonction passée à `map` n'est jamais évaluée
	\end{lstlisting}
	\caption{Exemple d'utilisation de \texttt{map}}
\end{figure}

\subsubsection{Opérateur de sélection (\texttt{flatMap})}

\begin{itemize}
	\item \code{def flatMap[U](f: T=>Signal[U]): Signal[U]}
\end{itemize}

Dans le cas des signaux, \texttt{flatMap} implémente une opération de sélection: étant donné un signal \texttt{a} de type \texttt{Signal[T]} et une transformation sous la forme d'une fonction \texttt{f: T => Signal[U]}, la fonction \texttt{f} est appliquée à la valeur actuelle du signal \texttt{a} afin d'obtenir un second signal \texttt{b} de type \texttt{Signal[U]} et retourne un troisième signal \texttt{c} également de type \texttt{Signal[U]} dont la valeur est en tout temps égale à celle du signal \texttt{b}. La fonction \texttt{f} est réévaluée à chaque changement d'état du signal \texttt{a} afin de définir un nouveau signal de référence \texttt{b}.

Si le signal \texttt{a} est indéfini, la fonction \texttt{f} n'est pas appliquée et le signal \texttt{c} est également considéré indéfini.

La fonction \texttt{flatMap}\footnote{\emph{bind} en Haskell, ou \texttt{>>=}} est la fonction universelle de transformation des monades. Elle est suffisamment générale pour permettre de définir toutes les autres fonctions de transformation comme des cas particuliers de \texttt{flatMap}. Par exemple, la transformation \texttt{a.map(f)} peut également s'écrire  sous la forme \texttt{a.flatMap(value => Constant(f(value))}.

\begin{figure}[h]
	\begin{lstlisting}
val choice: Signal[Int] = ...
def selectSignal(choice: Int): Signal[T] = ...
// L'état de `c` est identique à celui du signal retourné par `selectSignal` pour la valeur courante de `choice`
val c: Signal[T] = choice.flatMap(selectSignal)
	\end{lstlisting}
	\caption{Exemple d'utilisation de \texttt{flatMap}}
\end{figure}

\subsubsection{Opérateur de filtrage (\texttt{filter})}

\begin{itemize}
	\item \code{def filter(p: T=>Boolean): Signal[T]}
\end{itemize}

La fonction \texttt{filter} effectue une opération de filtrage d'un signal en appliquant un prédicat \texttt{p} à la valeur courante du signal et retournant un nouveau signal de même valeur si le prédicat est vérifié, ou un signal indéfini si le prédicat n'est pas vérifié.

\begin{figure}[h]
	\begin{lstlisting}
	val a: Signal[Int] = Source(4)
	val b: Signal[Int] = a.filter(_ % 2 == 0) // b.option -> Some(4)
	a := 5 // b.option -> None, b.value -> UndefinedSignalException
	\end{lstlisting}
	\caption{Exemple d'utilisation de \texttt{filter}}
\end{figure}

\subsubsection{Opérateur de combinaison (\texttt{fold} / \texttt{reduce})} \label{sec:sig-op-fold}

\begin{itemize}
	\item \code{def fold[U](a: U)(f: (U, T)=>U): Signal[U]}
	\item \code{def reduce[U >: T](f: (U, T)=>U): Signal[U]}
\end{itemize}

L'opérateur \texttt{fold} permet l'introduction d'un effet de \emph{mémoire} aux signaux. Il prend en paramètre un \emph{accumulateur initial} \texttt{a} de type \texttt{U} et une fonction de combinaison \texttt{f: (U, T) => U} permettant d'associer la valeur courante du signal à cet état pour produire un \emph{accumulateur courant}, également de type \texttt{U}, qui sera alors la valeur du signal produit par l'opérateur.

Lors d'un changement d'état du signal initial, l'\emph{accumulateur antérieur} est combiné à la nouvelle valeur du signal pour former le nouvel \emph{accumulateur courant}. Si le signal est indéfini la fonction \texttt{f} n'est pas évaluée et l'\emph{accumulateur antérieur} devient l'\emph{accumulateur courant} sans modification. Dans le cas où le signal est initialement indéfini, l'\emph{accumulateur initial} devient l'\emph{accumulateur courant} tel quel.

Le signal retourné par \texttt{fold} est toujours défini.

L'opérateur \texttt{fold} possède la particularité d'être affecté par le mode d'évaluation du signal qu'il produit. En mode paresseux, l'opérateur de combinaison ne serait appliqué que lors de l'accès au signal enfant. Il serait alors possible de manquer des changements d'état du signal parent. C'est pourquoi les signaux produits par l'opérateur \texttt{fold} ont toujours un mode d'évaluation différé afin d'obtenir un comportement déterministe et indépendant de la façon dont le signal enfant est utilisé.

À l'inverse de la fonction \texttt{fold} présente sur les collections de la bibliothèque standard Scala qui retourne une unique valeur pour une collection. La fonction \texttt{fold} des signaux retourne également un \texttt{Signal}. Le nom \emph{fold} ne fait ainsi pas référence au passage d'une collection à un élément unique, mais à la combinaison successive des différents \emph{états} du signal parent.

\begin{figure}[h]
	\begin{lstlisting}
val a: Signal[Int] = ...
val s: Signal[Int] = a.fold(0)(_ + _)
// Le signal `s` représente la somme de toutes les valeurs du signal `a`.

val b: Signal[Int] = ...
val m: Signal[Int] = b.fold(0)(_ max _)
// Le signal `m` représente la valeur maximale obtenue par le signal `b`.
	\end{lstlisting}
	\caption{Exemple d'utilisation de \texttt{fold}}
\end{figure}

L'opérateur \texttt{reduce} est une variation de l'opérateur \texttt{fold} dont l'\emph{accumulateur initial} est déterminé implicitement par l'état courant du signal parent. À l'inverse de la transformation \texttt{fold}, si l'état courant du signal parent est indéfini, alors le signal enfant est également indéfini. Dès lors que l'état du signal parent sera défini pour la première fois, l'état du signal enfant ne pourra plus être indéfini.

\begin{figure}[h]
	\begin{lstlisting}
val a: Signal[Int] = ...
val b: Signal[Int] = a.reduce((acc, x) => x)
// La valeur du signal `b` reflète la valeur du signal `a` lorsque celui-ci est défini. Lorsqu'il est indéfini, le signal `b` contient la dernière valeur définie du signal `a`. Si `a` n'a jamais été défini, `b` est indéfini.

val c: Signal[Int] = ...
val d: Signal[Int] = c.reduce(_ max _)
// Similaire à l'exemple correspondant pour `fold`, mais ne suppose pas une valeur intiale de 0. Si `c` représente des nombres négatifs, la version avec `fold` ne serait pas correcte (il faudrait utiliser Int.MinValue).
	\end{lstlisting}
	\caption{Exemple d'utilisation de \texttt{reduce}}
\end{figure}

\subsubsection{Opérateurs d'encapsulation (\texttt{wrap / unwrap})}

\begin{itemize}
	\item \code{def wrap: Signal[Option[T]]}
	\item \code{def unwrap[U](implicit ev: T <:< Option[U]): Signal[U]}
\end{itemize}

L'opérateur \texttt{wrap} transforme un signal d'origine de type \texttt{T} en un signal de type \texttt{Option[T]}. Lorsque le signal initial est défini, ce nouveau signal sera défini à \texttt{Some(value)}, avec \texttt{value} la valeur actuelle du signal original. Dans le cas où il serait indéfini, le signal de retour est défini à \texttt{None}.

Cette opération garantit ainsi un signal toujours défini à une instance d'\texttt{Option} et permet de contourner la sémantique des opérateurs de transformations vis-à-vis des signaux indéfinis. Ceci permet de traiter avec des opérateurs tel que \texttt{map}, \texttt{fold}, etc., les valeurs définies mais également indéfinies d'un signal.

\begin{figure}[h]
	\begin{lstlisting}
// Construction d'un signal avec une valeur par défaut qui sera utilisée si le signal original est indéfini
def withDefault[U >: T](s: Signal[T]])(default: U): Signal[U] = {
	val a: Signal[Option[T]] = s.wrap
	a.map((opt: Option[T]) => opt.getOrElse(default))
}
	\end{lstlisting}
	\caption{Exemple d'utilisation de \texttt{wrap}}
\end{figure}

L'opération \texttt{unwrap} effectue la transformation inverse. Si le signal initial possède une valeur \texttt{Some(v)}, la valeur du signal retourné est simplement égale à \texttt{v}. Dans le cas où le signal original vaut \texttt{None}, le signal résultant est indéfini. Cette opération ne peut être appliquée que sur une instance de signal de type \texttt{Signal[Option[U]]} pour un \texttt{U} quelconque.

Le paramètre implicite n'est rien d'autre qu'une implémentation de cette contrainte \footnote{La même technique est utilisée par les collections de Scala pour l'implémentation de la méthode \texttt{flatten}.}. Si celle-ci est respectée, le compilateur Scala sera en mesure de fournir une valeur pour ce paramètre implicite. En revanche, si le type du signal ne correspond pas, une erreur de compilation liée à l'absence du paramètre implicite sera générée. Le développeur n'a donc pas à se soucier de ce paramètre implicite et peut se contenter d'utiliser cette méthode tel que si elle ne prenait aucun paramètre.

\begin{figure}[h]
	\begin{lstlisting}
// Définition de l'opérateur `reduce` à partir de `fold` et `unwrap`
def reduce[U >: T](s: Signal[T])(op: (U, T) => U): Signal[U] = {
	val a: Signal[Option[U]]] =
		s.fold[Option[U]](None) { (prev: Option[U], cur: T) =>
			prev.map(op(_, cur))
		}
	a.unwrap
}
	\end{lstlisting}
	\caption{Exemple d'utilisation de \texttt{unwrap}}
\end{figure}

\subsection{Observateurs} \label{sec:sig-obs}

Les observateurs permettent d'ajouter des effets de bords aux changements d'états d'un signal. De la même façon que les sources sont les points d'entrée dans un graphe de signaux, les observateurs sont les points de sorties.

Un observateur se construit par l'invocation du constructeur
\begin{center}
	\code{Observer.apply(body: => Unit): Observer}
\end{center}

Il se comporte de façon similaire à un signal différé. Lorsque l'état d'un signal change, tous les observateurs attachés à ce signal sont placés dans une queue. Le processus se poursuit alors pour les signaux enfants, ajoutant les observateurs attachés à ces signaux à la queue. Une fois l'ensemble des signaux enfants invalidés, les observateurs sont invoqués (§ \ref{sec:sig-mut-context}).

Un observateur peut se trouver dans deux états distinct:
\begin{enumerate}
	\item Attaché (\emph{bound}): l'observateur est actif et sera invoqué pour chaque changement d'état des signaux qu'il observe.
	\item Détaché (\emph{unbound}): l'observateur est inactif, il est effectivement retiré de tous les signaux qu'il observait précédemment et ne sera plus invoqué jusqu'à ce qu'il soit explicitement réactivé.
\end{enumerate}

Un observateur peut être attaché ou détaché en invoquant les méthodes \texttt{bind()} et \texttt{unbind()}. Lorsqu'un observateur transitionne de l'état détaché à l'état attaché, sa fonction de définition est invoquée afin de déterminer les signaux auxquels l'attacher.

Lors de la construction d'un nouvel observateur, celui-ci est initialement \emph{attaché}, impliquant que la fonction utilisée dans sa définition est immédiatement invoquée. S'il est nécessaire de construire un observateur dans l'état \emph{détaché}, le constructeur alternatif peut être utilisé
\begin{center}
	\code{Observer.unbound(body: => Unit): Observer}
\end{center}
Dans ce cas, il sera nécessaire de l'attacher aux signaux qu'il écoute explicitement en invoquant la méthode \emph{bind} sur l'objet retourné.

\subsection{Contexte de mutation} \label{sec:sig-mut-context}

Un contexte de mutation représente une mutation du graphe de signaux considérée atomique du point de vue des observateurs et des signaux différés. Tant qu'un contexte de mutation est ouvert, aucun observateur ou signal différé n'est calculé. À la place, ceux-ci sont placé en attente jusqu'à la fermeture du contexte de mutation.

Un tel contexte peut être construit explicitement sous la forme
\begin{lstlisting}
Signal.atomically {
	// mutations...
}
\end{lstlisting}
ou implicitement en effectuant la mutation d'un signal Source. Chaque mutation d'une \texttt{Source} ouvre en effet un nouveau contexte de mutation puis le ferme immédiatement.

Lorsqu'un contexte de mutation est ouvert tandis qu'un autre contexte est déjà ouvert, le contexte existant est réutilisé. Par exemple lors de la mutation d'une source dans un bloc \texttt{Signal.atomically}, le contexte enfant créé par la source sera ignoré et aucun observateur ni signal différé ne sera traité avant la fermeture du contexte extérieur.

L'intérêt de cette construction se révèle en considérant la nature récursive de l'invalidation des signaux. Lorsqu'un signal source est modifié, l'ensemble des ses signaux enfants doit être invalidé. Si l'un de ces signaux utilise la sémantique d'évaluation \emph{différée}, il est nécessaire de le recalculer. S'il possède des observateurs, il est également nécessaire de l'invoquer avant de retourner au code appelant. De plus, chaque signal enfant peut également posséder un ensemble de signaux enfants pour lesquels l'opération doit être répétée. Des structures en diamant sont également possibles, causant une double invalidation d'un signal enfant (figure \ref{fig:sig-diamond-dependencies}).

\begin{figure}[h]
	\centering
	\includegraphics[width=2cm]{img/signals_diamond}
	\caption{Exemple de dépendance en diamant}
	\label{fig:sig-diamond-dependencies}	
\end{figure}

Dans de telles la situations, la présence du contexte de mutation permet d'assurer une sémantique \emph{exactly-once} pour les observateurs et les signaux différés. Un observateur n'est invoqué, ou un signal différé recalculé, qu'une seule et unique fois par contexte de mutation, lorsque celui-ci est fermé.

Plus spécifiquement, les règles suivant s'appliquent:
\begin{enumerate}[label=\alph*]
	\item Aucun observateur ou signal différé n'est évalué tant qu'un contexte de mutation est ouvert. Il est à la place placé dans une queue interne au contexte.
	\item Dès lors que le contexte de mutation est fermé, l'ensemble des signaux différés en queue sont évalués et mis à jour. Ces signaux sont évalués dans l'ordre dans lequel ils ont été placés dans la queue, mais un même signal ne sera évalué qu'une seule fois.
	\item Si un signal en queue dépend de l'état d'un autre signal différé placé après lui dans la queue, cet autre signal est évalué immédiatement et sa position dans la queue est ignorée.
	\item Une fois l'ensemble des signaux différés évalués, les observateurs sont invoqués dans l'ordre dans lequel ils ont été ajoutés à la queue. De façon similaire aux signaux, un observateur ne sera invoqué qu'une seule et unique fois par contexte.
	\item La fermeture du contexte est elle-même effectuée dans un nouveau contexte de mutation. Celui-ci est ouvert dès lors que le contexte parent débute sa procédure de fermeture et sera fermé une fois l'ensemble des signaux et observateurs invoqués. S'il n'y a aucun signal ni observateur en queue, un nouveau contexte n'est pas ouvert.
	\item L'opération de fermeture ne peut pas être interrompue, une exception lancée lors de l'évaluation d'un signal ou d'un observateur interrompt l'opération en cours mais n'affecte pas les autres signaux et observateurs qui seront tout de même.
	\item Si au moins une exception a été lancée pendant le processus de fermeture d'un contexte de mutation, une exception \footnote{De type \texttt{MutationContext.MutationException}} sera lancée à la fin de l'opération et contiendra l'ensemble des exceptions capturées. Ce mécanisme est conçu pour faciliter le \emph{debug} de l'application et son usage doit être évité. Les exceptions possibles devraient être traitées localement dans les signaux ou les observateurs.
\end{enumerate}

Ces règles ont pour but de simplifier la conceptualisation du comportement d'un graphe de signaux. Chaque mutation s'accompagne au maximum d'une évaluation des observateurs et signaux différés. Cette garantie est particulièrement intéressante lors de l'utilisation de signaux utilisant la sémantique \emph{différée} puisqu'elle permet de rendre des opérations tels que \texttt{fold} indépendantes de la structure du graphe, aussi complexe soit-elle.

\subsection{Parallélisme}

Le parallélisme est un concept majeur dans le développement logiciel depuis que les processeurs tendent à se paralléliser plus qu'il n'accélèrent. Utiliser efficacement un processeur moderne signifie être capable de répartir les calculs à effectuer sur les multiples cœurs d'exécution qu'il met à disposition.

Avec la parallélisation de l'exécution, des comportements non-déterministes apparaissent. Il n'existe plus aucune garantie concernant l'ordre dans lequel les opérations seront effectuées entre les différents fils d'exécution. Des facteurs externes tel que le système d'exploitation et les autres applications exécutée de façon concurrente par l'utilisateur se partagent tous les ressources du système et affecte l'ordonnancement des opérations.

Il est alors nécessaire d'intégrer à l'application \emph{multi-threadée}, des points de synchronisation ou des verrous pour restaurer un certain nombre de garanties quant à l'ordre d'exécution des instructions. Ces mécanismes sont généralement coûteux en terme de performances et leur usage excessif peut conduire à une exécution effectivement plus lente que lors de l'utilisation d'un unique \emph{thread}. L'\emph{overhead} de la synchronisation éclipsant alors le gain de performance apporté par le parallélisme.

La question se pose alors de l'utilisation des signaux dans un contexte parallèle. Dans le cadre de ce travail, les signaux ont été utilisés pour la construction de l'interface utilisateur côté client. JavaScript est un environnement \emph{single threaded} n'offrant aucun mécanisme de parallélisation \footnote{Plus spécifiquement, il n'existe pas de parallélisation avec mémoire partagée. L'environnement web défini les \emph{Web Workers} qui sont effectivement des processus concurrents, mais dont la communication avec le processus principal se fait par échange de messages et événements.}. La concurrence n'était donc pas un problème.

Cependant, les signaux ne sont pas limités à la construction d'interfaces web et peuvent être utilisés pour modéliser des dépendances complexes dans un ensemble d'informations manipulées par une application possiblement parallèle. Afin d'étudier les implications de la parallélisation, deux cas d'utilisation ont été imaginés:
\begin{enumerate}
	\item L'utilisation \emph{multi-threadée} d'un unique graphe de signaux
	\item L'utilisation des signaux comme mécanisme de parallélisation
\end{enumerate}
Une analyse théorique de ces deux situations est effectuée dans les sections ci-après. \textit{Trouver mieux comme transition...}

\subsubsection{Utilisation \emph{multi-threadée} d'un unique graphe de signaux}

Dans cette situation, un graphe unique de signaux est accédé parallèlement par de multiples \emph{threads} de l'application. La tâche de parallélisation est attribuée à l'utilisateur de la bibliothèque qui est alors responsable de déterminer le nombre de \emph{threads} à exécuter et leurs tâches respectives. Il attend du graphe de signaux un certain nombre de garanties:
\begin{itemize}
	\item Cohérence: les données stockées dans chaque nœuds du graphe doivent rester cohérentes par rapport à l'ensemble du graphe. Si un signal dépend d'un autre et que l'état de ces deux signaux est actuellement en cache, les valeurs de ces deux signaux doit correspondra à la relation qui les unis. La figure \ref{fig:sig-inconsistency} illustre une telle situation où les données en cache ne correspondent pas à la relation.
	
	\begin{figure}
		\centering
		\includegraphics[width=6cm]{img/signals_coherence.eps}
		\caption{Signaux incohérents}
		\label{fig:sig-inconsistency}
	\end{figure}

	Cette incohérence peut provenir d'un croisement des opérations d'invalidations et de calcul d'un signal \emph{lazy}. Si un signal d'invalidation est reçu par un nœud tandis que qu'un autre \emph{thread} est déjà en train de recalculer ce même nœud, il est possible que l'invalidation soit ignorée, malgré que le calcul soit effectué avec des données périmées.
	
	\item Absence d'inter-blocage: une solution pour résoudre les problèmes de cohérence est l'introduction de synchronisation et de verrous. Il est cependant important de ne pas verrouiller \emph{trop}. Si chaque accès aux signaux nécessite le verrouillage de l'ensemble du graphe, les différents fils d'exécutions se retrouveraient en attente permanente et les avantages du parallélisme seraient perdus.
	
	À l'inverse, dans le cas d'un verrouillage fin, nœud par nœud, il est alors important de s'assurer de l'absence d'inter-blocage, les mises à jour d'un graphe de signal pouvant être initiées parallèlement à partir de multiples nœuds.
	
	\begin{figure}
		\centering
		\includegraphics[width=2.5cm]{img/signals_interblock.eps}
		\caption{Situation d'inter-blocage potentielle}
		\label{fig:sig-interblock}
	\end{figure}

	La figure \ref{fig:sig-interblock} illustre une telle situation. Si le signal \emph{c}, en étant calculé, verrouille le signal \emph{a} tandis que le signal \emph{d} verrouille le signal \emph{b} de façon concurrente, les deux signaux se retrouvent bloqués en attente du second signal nécessaire à leur évaluation.
	
	Une solution potentielle à cette situation est d'imposer un ordre dans l'acquisition des verrous entre les signaux, par exemple sur la base du \texttt{hashCode} de l'objet signal étant verrouillé. La question de savoir si cela est suffisant pour garantir l'absence d'inter-blocage dans le graphe n'a pas été approfondie.
	
	\item Sémantique des observateurs: dans une situation non-parallèle, un observateur est invoqué \emph{exactement une fois} lors de la fermeture du contexte de mutation et avant le retour au code utilisateur ayant initié la mutation. Que faire lorsque de multiples nœuds sont mis à jour de façon parallèle avec des observateurs attachés ? 
	
	Faut-il exécuter l'observateur une fois par mutation, avec des données potentiellement périmées ? Faut-il plutôt différé l'exécution de l'observateur jusqu'à ce que l'ensemble du graphe soit stabilisé ? Dans ce cas, quel \emph{thread} est responsable d'invoquer l'observateur ? Que faire si le graphe ne se stabilise jamais, c'est à dire
	que des modifications sont continuellement apportées aux données, l'observateur se retrouverait alors différé indéfiniment ?
	
	La problématique est identique en ce qui concerne les signaux différés puisqu'ils partage leur sémantique d'évaluation avec les observateurs. Est-ce que cela a toujours un sens dans un environnement parallèle ou est-il nécessaire d'établir des règles supplémentaires, spécifiques aux signaux différés.
\end{itemize}

Toutes ces questions attestent de la difficulté d'établir des règles d'évaluation claires et simples dans un contexte \emph{multi-threadé}. Ce qui correspond à un cas d'utilisation peut ne pas être adapté à un autre.

Les approches les plus simples, comme par exemple exécuter les observateurs une fois par mutation sur le \emph{thread} ayant initié la mutation et sans se préoccuper d'exposer des données périmées dans le graphe, sont les plus simples à implémenter mais également les moins utiles pour le développeur. Les approches plus strictes, plus utiles au développeur, sont également plus complexes à implémenter. L'impact sur les performances est également à considérer.

\subsubsection{Utilisation des signaux comme mécanisme de parallélisation}

Une approche alternative de la question du parallélisme consiste à se servir du graphe de signaux comme primitive de parallélisation. Dans ce cas, ce n'est plus le développeur qui est responsable de paralléliser son application, mais la bibliothèque de signaux. L'objectif est alors de calculer automatiquement les différents nœuds du graphe de façon concurrente.

Une approche possible serait de modifier la signature des méthodes d'accès à l'état d'un signal pour retourner des instances de \texttt{Future}. En utilisant le mécanisme d'\texttt{ExecutionContext} de la bibliothèque Scala, la gestion du \emph{thread pool} est déléguée à la plateforme, tout en laissant au développeur la possibilité de configurer son fonctionnement si nécessaire.

En ce qui concerne les observateurs, une approche intéressante serait d'associer à chaque mutation une invocation des observateurs, au cours de laquelle le graphe est dans un état cohérent à la suite de cette mutation. L'objectif est ici de pouvoir utiliser un graphe de signaux comme implémentation d'une fonction de la forme \texttt{(A, B, C, ...) => Future[Z]}.

Une telle fonction serait construite autour d'un graphe disposant d'une source par paramètre et d'un signal feuille exprimant la valeur de retour par transformation des signaux sources, potentiellement avec des nombreux niveaux de signaux intermédiaires. L'ensemble des sources seraient alors mises à jour de façon atomique, provoquant une mise à jour de l'ensembles des signaux du graphe puis une invocation d'un observateur attaché au nœud feuille. La figure \ref{fig:sig-pipeline} présente un exemple de ce concept.

\begin{figure}[h]
	\begin{lstlisting}
val A = Source.undefined[String]
val B = Source.undefined[Int]
// ... signaux intermédiaires
val Z = Signal { ... }

def foo(a: String, b: Int): Future[Boolean] = {
	val p = new Promise[Boolean]
	Signal.atomically {
		A := a
		B := b
		Observer.once(Z) { res => p.resolve(res) }
	}
	p.future
}
	\end{lstlisting}
	\caption{Exemple d'utilisation d'un graphe de signaux comme mécanisme de parallélisation}
	\label{fig:sig-pipeline}
\end{figure}

Les deux approches peuvent également être combinées. Si l'observateur invoqué sur le nœud feuille observe un état cohérent du graphe même dans le cas d'invocations concurrentes, le graphe fonctionne alors comme un \emph{pipeline} d'évaluation où les données sont propagées le long des signaux jusqu'à attendre le nœud feuille avec la possibilité de débuter un nouveau calcul au niveau des racines tandis que le premier n'a pas encore atteint l'extrémité du graphe. D'une façon, dès lors que tous les enfants d'un signal ont été calculés, il est possible de débuter un nouveau calcul au niveau de ce signal.

Par exemple, dans la structure en diamant de la figure \ref{fig:sig-diamond-dependencies}, le signal \emph{D} dépend indirectement de la valeur de \emph{A}. Cependant, une fois que les valeurs de \emph{B} et \emph{C} ont été calculées, le signal \emph{A} peut être réutilisé pour le prochain calcul sans affecter le calcul de \emph{D} puisque la valeur correcte, de son point de vue, de \emph{A} a été \emph{capturée} dans les valeur de \emph{B} et \emph{C}. Une fois le calcul de \emph{D} terminé, les signaux \emph{B} et \emph{C} peuvent à leur tour être réutilisés pour le prochain calcul, sans attendre la fin de la propagation.
