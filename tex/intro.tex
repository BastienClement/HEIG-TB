\chapter{Introduction}

De plus en plus d'activités sociales sont supportées par des technologies de l'information. Les applications web deviennent des médiateurs d'interactions sociales entre personnes, comme par exemple les réseaux sociaux. Des groupes de personnes se rencontrent dans le cyberespace pour s'échanger et poursuivre leurs loisirs. Ces interactions ne sont plus seulement asynchrones, mais deviennent synchrones, par exemple dans le cas des jeux vidéo en ligne. Des groupes de personnes relativement importants se réunissent pour jouer ensemble. Certains jeux nécessitent un haut degré de collaboration entre les membres d'un groupe. Cette collaboration peut être facilité par une application de gestion collaborative.

Les technologies web évoluent très rapidement coté client (navigateur) et permettent de développer des applications de plus en plus interactives et temps réel. Notamment les frameworks récents comme ReactiveX offrent un nouveau paradigme de programmation réactive qui simplifie considérablement le développement d'applications hautement interactives.

\section{Programmation réactive-fonctionnelle}

La programmation réactive-fonctionnelle est une combinaison des paradigmes de programmation fonctionnelle et de programmation réactive.

Ce premier paradigme, fonctionnel, met en avant l'utilisation de structure de données immutables et de l'application de fonctions sur ses structures afin d'en dériver de nouvelles. Les effets de bords et les états globaux sont évités par l'utilisation de fonctions pures ne dépendant que de leurs paramètres. Les principes de composabilité des fonctions et de transparence référentielle qui en découlent sont alors mis en avant pour promouvoir un style de programmation qui se veut plus clair et avec moins d'effets surprenant pour le développeur.

La programmation réactive quant à elle prône une approche basée en premier lieu sur les données sources utilisées par l'application, les transformations qui leur sont appliquées et le maintient d'un état cohérent dans l'ensemble du logiciel lors des changements d'états du système.

Dans l'approche mixte réactive-fonctionnelle, les sources de données réactives sont manipulées comme des structures fonctionnelle classiques et des fonctions, pures, leur sont appliquées afin de produire de nouvelles données réactive dérivée. Une relation de dépendance existe entre la donnée réactive produite en résultat de la fonction et la donnée source utilisée. L'objectif du système réactif-fonctionnel est alors de garantir qu'en cas de modification de la donnée source, les données dérivées soient correctement mises à jour par une réapplication de la fonction utilisée en premier lieu.

\section{Objectifs}

Ce travail a pour objectif le développement d'une application web hautement interactive avec le langage de programmation Scala, basée sur les principes de la programmation réactive-fonctionnelle et intégrant une gestion précises et temps-réel des interactions entres ses utilisateurs, dans le but de permettre l'organisation d'un groupe de joueurs dans un jeu en ligne multi-joueurs.

Dans cette optique, une bibliothèque réactive-fonctionnelle -- Xuen -- sera développée en premier lieu afin de fournir les composants de base utilisés dans la construction de l'application: \emph{signaux}, \emph{templates} et \emph{data-binding}. L'accent sera mis sur le développement d'une bibliothèque générique et réutilisable, indépendante de l'application finale.

\section{Technologies utilisées}

\subsection{Web Components}

\emph{Web Components} un ensemble d'extensions aux spécifications HTML et DOM destinées à permettre le développement de composants isolés et réutilisables pour la construction de page web, de façon simple et portable grâce au support natif de la technologie dans les navigateur modernes.

Le nom \emph{Web Components} regroupe en réalité un ensemble de quatre technologies distinctes, dont le support varie selon le navigateurs utilisé:
\begin{enumerate}
	\item Templates
	\item HTML Imports
	\item Custom Elements
	\item Shadow DOM
\end{enumerate}

Le concept est généralement attribué à Alex Russell \cite{russell2011} qui le présente à l'occasion de la \emph{Fronteers Conference 2011}. Il est alors un développeur de la bibliothèque d'interface Dojo avant d'être engagé par Google pour travailler au développement de la plateforme web, du moteur de rendu Blink et du navigateur Google Chrome \cite{russellIN}.

La première implémentation est développée en 2013 par Google comme fondations pour sa bibliothèque \emph{Polymer} \cite{polymer-project}, principalement dans un but expérimental et afin de collecter des avis. Les autres développeurs de navigateur, notamment Mozilla, Microsoft et Apple n'y participent pratiquement pas et le résultat ne fait pas l'unanimité \cite{stateOfWebComp}. De nombreuses discussions sont alors entreprises pour trouver un terrain d'entente et arriver à une spécification finale commune.

\subsubsection{État actuel de l'implémentation}

Aujourd'hui, les efforts d'implémentation sont toujours en cours. Les dernières versions des navigateurs Chrome, Opera et Safari supportent la plus grande partie de la spécification. L'implémentation de Firefox est toujours en cours de développement tandis que Microsoft considère son implémentation comme \emph{haute-priorité}. La table \ref{tab:webcomp-support} résume l'état actuel des implémentations.

\begin{table}[h]
	\centering
	\caption{Support des technologies Web Component}
	\label{tab:webcomp-support}
	\begin{tabular}{@{}lcccc@{}}
		\toprule
		& Chrome/Opera & Firefox   & Safari  & Edge      \\ \midrule
		Templates       & Stable         & Stable    & Stable    & Partiel   \\
		HTML Imports    & Stable         & Non prévu & Non prévu & Considéré \\
		Custom Elements & Partiel        & En cours  & Partiel   & Considéré \\
		Shadow DOM      & Stable         & En cours  & Buggé   & Considéré \\ \bottomrule
	\end{tabular}
\end{table}

Concernant \emph{Custom Elements} et \emph{Shadow DOM}, les versions initiales de ces technologies sont à présents appelées \emph{versions 0}. Les versions actuelles dont il est question ici sont les \emph{versions 1}.

L'implémentation des \emph{Custom Elements v1} par Chrome, Opera et Safari est complète en ce qui concerne la définition de nouveaux éléments indépendants. Il n'est cependant pas possible pour le moment d'étendre des éléments natifs du navigateur, fonctionnalité prévue par la spécification. Dans le cadre de ce travail, cette fonctionnalité n'étant pas utilisée, il est possible de considérer ces implémentations comme complètes.

Les bugs mentionnés pour l'implémentation de \emph{Shadow DOM v1} par Safari concernent des problèmes liés aux sélecteurs CSS \texttt{:host} et \texttt{::slotted} introduit par la spécification.

\subsubsection{Templates}

Cette extension ajoute la balise \texttt{<template>} au standard HTML. Son objectif est d'offrir aux développeur un mécanisme permettant l'inclusion de fragments de page dans un document HTML sans que celui-ci ne soit exécuté, il est alors dit \emph{inerte}.

Comme exemple, sans cet élément, une image avec un attribut \texttt{src} était immédiatement téléchargée par le navigateur. Dans une application web utilisant le framework Angular 1, il était alors fréquent de voir des images déclarée en utilisant l'attribut spécial \texttt{ng-src} qui était ensuite transformé en simple \texttt{src} une fois l'évaluation de l'expression de \emph{databinding} par le framework. Sans cela, le navigateur aurait tenté de charger une image à l'adresse "\texttt{\{\{imgSrc\}\}}", résultant en une erreur avant que le framework Angular puisse avoir l'occasion d'évaluer l'expression et de modifier l'attribut.

Avec l'élément \texttt{<template>}, son contenu est \emph{parsé} et transformé en structure de noeuds DOM de façon similaire à n'importe quel autre élément, mais leurs effets ne sont pas exécutés: les images ne sont pas chargées, les scripts pas exécutés, les styles pas appliqués, etc.

Le contenu de cet élément est ensuite cloné de façon dynamique au \emph{runtime} par un script puis inséré sous un autre noeud du document en utilisant les APIs du DOM. Ce contenu sera alors exécuté de façon habituelle. Un même template peut également être cloné et inséré plusieurs fois, permettant la factorisation de code répété à travers un document HTML.

\subsubsection{HTML Imports}

Cette spécification introduit la possibilité pour une page web en HTML d'inclure un second document HTML. Ceci se traduisant par un attribut \texttt{rel="import"} sur l'élément \texttt{<link>}, déjà utilisé pour lier une feuille de styles CSS à un document.

L'objectif visé est la possibilité pour un composant développé avec les API Web Components d'être contenu dans un unique fichier \texttt{.html} et chargé par la page hôte sans recourir à JavaScript.

En pratique, cette fonctionnalité ne semble pas convaincre Mozilla et Apple qui n'ont pour l'instant pas annoncé une intention de l'intégrer dans leurs navigateurs Firefox et Safari.

Dans le cadre de ce travail, cette partie des Web Components ne sera pas utilisée. En effet, l'objectif est de permettre de définir l'ensemble du composant à partir de code Scala compilé par Scala.js. Ce qui signifie combiner au niveau du code source la définition du comportement du composant (en Scala) avec son template (HTML) et son style visuel (CSS). Ainsi, l'ensemble des composants définis sont chargés d'un coup, en même temps que le code JavaScript produit par Scala.js.

\subsubsection{Custom Elements}

Cette technologie introduit une API pour la définition de nouveau élément DOM. En pratique, cela se traduit par la capacité à créer de nouvelle balise qui seront reconnue par le navigateur et d'y associer des comportements spécifiques lors de son instantiation, attachement ou détachement du document.

Les réponses du composants aux interactions de l'utilisateurs se font quant à elles sur la base des événements classiques disponibles en JavaScript: par exemple enregistrement d'un gestionnaire pour l'événement \texttt{click} ou \texttt{keydown} sur l'élément, tel qu'il serait fait pour un simple élément \texttt{<div>}.

La spécification prévoit également la possibilité d'étendre une balise existante selon une forme d'héritage. Il est ainsi possible de définir un type de bouton personnalisé, qui hériterait du comportement standard d'un bouton mais qu'il serait alors possible d'altérer. En pratique, cette fonctionnalité n'est pas encore supportée par les navigateurs.

La définition de nouvelle balise est un concept clé de ce travail puisque chaque composant créé en Scala.js sera instancié par l'utilisation de sa balise associée dans le template d'un autre élément. En revanche, l'extension d'éléments existant ne sera pas exploité. Il est en effet trivial d'atteindre un effet similaire en définissant un nouvel élément contenant l'élément à altérer dans son sous-arbre DOM.

\subsubsection{Shadow DOM}

Probablement la spécification la plus complexe d'un point de vue implémentation pour les navigateurs et la plus difficile à \texttt{polyfill} en JavaScript. Elle définit un mécanisme permettant d'encapsuler un sous-arbre DOM et des styles CSS associés et de les rendre invisibles de l'extérieur. Ainsi:

\begin{itemize}
	\item les styles CSS déclarés hors du sous-arbre ne s'appliquent pas aux éléments du sous-arbre et inversement pour les styles déclarés dans le sous-arbre;
	
	\item les identifiants HTML (attributs \texttt{id}), en principe unique dans un document, peuvent être réutilisés dans un sous-arbre;
	
	\item les fonctions \texttt{getElementById} ou \texttt{querySelector} dépendent de l'élément depuis lequel elles sont appelées et ne peuvent pas traverser une frontière formée par un sous-arbre;
	
	\item les événements sont \emph{retargeted} à leur sortie d'un sous-arbre, leur attribut \texttt{target} indiquant depuis quel élément ils ont été émis est modifié pour référencer le noeud à la racine du sous-arbre au lieu de l'élément qui a réellement émis l'événement, à l'intérieur du sous-arbre.
\end{itemize}

Ce mécanisme est également clé à la réalisation de ce projet puisque chaque élément sera associé à son sous-arbre DOM caché contenant une instance de son template.

\subsection{Scala.js}

\textit{Scala.js est un compilateur Scala \to JavaScript au lieu de Scala \to Java Bytecode. Il permet l'exécution de code Scala dans le navigateur et propose une modèle d'interopérabilité avec JavaScript permettant de manipuler facilement les API web du navigateur depuis Scala. Sémantique très proche de Scala/JVM.}

\textit{À ajouter: un peu d'histoire. Projet de thèse EPFL, soutenu par le Scala Center, une des trois plateforme officiellement développée de Scala avec ScalaNative et Scala/JVM. Stable depuis plusieurs années pour un usage en production. De nombreuses bibliothèque Scala cross-compilées pour Scala.js.}

\subsubsection{Limitations actuelles en rapport avec les Web Components}

\textit{Web Components requiert des classes ES6, obligation du coup d'utiliser le mode d'émission ES6 de Scala.js qui est expérimental. En pratique semble fonctionner. Mais du coup impossible d'utiliser Google Closure Compiler pour optimiser le script final. Conduisant à des fichiers JavaScript beaucoup plus volumineux que nécessaire. Support d'ES6 dans la roadmap de Closure Compiler, mais pas encore là. Une simple compression GZip réduit considérablement l'impact du problème.}