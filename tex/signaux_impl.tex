\section{Implémentation}

\subsection{Hiérarchie complète}
\label{sec:sig-hierarchy}

La figure \ref{sec:sig-hierarchy} présente la hiérarchie formée par les différentes classes de signaux. Cette section aborde plus en détails les spécificités de chacune d'elles.

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{img/sig_hierarchy.eps}
	\caption{Hiérarchie des signaux}
	\label{fig:sig-hierarchy}
\end{figure}

L'implémentation des signaux est organisée sur la base du raffinement successif de la sémantique d'un signal. Chaque niveau laisse généralement un point de sa sémantique indéfini, sous la forme d'une méthode abstraite à implémenter par les sous-classes.

\begin{itemize}
	\item \texttt{Signal}: la vue la plus générale d'un signal, ce trait défini les méthodes de transformation et d'accès à l'état du signal. La fonction \texttt{def option: T} est indéfinie et doit retourner l'état courante du signal.
	\item \texttt{Immutable}: redéfini \texttt{option} en \texttt{val} puisque l'état est immutable, mais laisse la valeur abstraite.
	\item \texttt{Constant}: défini \texttt{val option = Some(value)}
	\item \texttt{Undefined}: défini \texttt{val option = None}
	\item \texttt{Mutable}: déclare la méthode abstraite \texttt{def current: Option[T]}, représentant également l'état du signal mais dont le nom indique clairement la mutabilité du signal.
	
	Défini la méthode \texttt{option} en se basant sur \texttt{current} mais y ajoute la détection automatique des signaux enfants. De cette façon, toutes les méthodes de \texttt{Signal}, en utilisant directement ou indirectement \texttt{option}, obtiennent également les mécanismes de détection.
	
	\item \texttt{Source}: défini une variable interne pour stocker l'état de la source, implémente \texttt{current} sur la base de cette variable.
	
	Ajoute également les opérations de mutation explicites.
	
	\item \texttt{Child}: déclare la méthode abstraite \texttt{def generate: Option[T]}, appelée lorsque l'état du signal doit être calculé. Implémente \texttt{current} sur la base de \texttt{generate} et y ajoute le mécanisme de \emph{memoization}.
	
	Défini la méthode \texttt{def invalidate(): Unit} qui permet d'effacer l'état mémorisé du signal et d'invalider récursivement tous les signaux enfants. Cette méthode est en principe appelée par \texttt{Mutable}.
	
	\item \texttt{Lazy}: trait \emph{marqueur}, l'implémentation de \texttt{Child} utilise déjà la sémantique \emph{lazy} par défaut. Il n'y a donc rien à modifier.
	
	\item \texttt{Deferred}: surcharge la méthode \texttt{invalidate} définie par \texttt{Child} en insérant le signal dans la queue du contexte de mutation courant. De cette façon, ce signal sera recalculé de façon différée à la fermeture du contexte de mutation.
	
	\item \texttt{Expression}: implémente \texttt{generate} sur la base de l'expression passée en paramètre.
	
	\item \texttt{LazyExpr}: combine \texttt{Expression} avec \texttt{Lazy}
	\item \texttt{DeferredExpr}: combine \texttt{Expression} avec \texttt{Deferred}
\end{itemize}

Les classes \texttt{LazyExpr} et \texttt{DeferredExpr} sont privées. S'il est nécessaire dans le code utilisateur de déterminer la sémantique d'une expression, un \emph{pattern matching} sur les traits \texttt{Lazy} et \texttt{Deferred} peut être effectué. Il est également possible de tester si un signal est une expression constante avec l'opérateur \texttt{with}, sous la forme: \code{case e: Expression with Lazy}.

\subsection{Détection automatique des dépendances}
\textit{Cette classe est un concept récent, donc l'implémentation n'est pas encore réalisée:}
{\itshape \begin{itemize}
	\item Allocation d'un \texttt{DependencyTracer}
	\item Celui-ci utilise une \texttt{DynamicVariable} pour se rendre visible de façon dans toutes les fonctions invoquées dans le même thread d'exécution
	\item Évaluation de l'expression
	\item Le tracer détecte les dépendances, construction dynamique du graphe
	\item Suppression du tracer
\end{itemize}}
\textit{Actuellement le comportement du tracer pour les signaux est implémentée dans les traits \texttt{Mutable} et \texttt{Lazy}, la factorisation dans une classe indépendante à pour but de permettre l'utilisation du même mécanisme de la définition des observateurs.}

\subsection{Implémentation des opérateurs de transformations}
\textit{Les opérateurs de transformations sont implémentés sur la base des signaux expression.}

\textit{Avantage: pas besoin de déclarer une hiérarchie de classe représentant chaque transformation (au moins une bibliothèque réactive-fonctionnelle est implémentée de cette façon, référence à retrouver...), réutilisation des mécanismes de détection de dépendances.}

\textit{De plus, puisque l'évaluation de la transformation prend la forme d'une expression, il est possible de faire référence à d'autres signaux à l'intérieur de la transformation et le signal enfant sera ainsi enfants de plus d'un parent. Bien que ce style soit peu-recommandable, cette implémentation permet de le supporter sans surprise et permet ainsi des restrictions uniforme à travers l'API des signaux. Exemple:}
\begin{lstlisting}
val a: Signal[Int] = ...
val b: Signal[Int] = ...
val c = b.map(v => v * 2 + a.value)
// `c` est enfant de `a` et `b`
\end{lstlisting}

\subsection{Modèle push, pull ou hybride}

Deux modes de fonctionnement sont généralement décrit pour des systèmes fonctionnels-réactifs: \emph{push} et \emph{pull}.

L'approche \emph{push} se base sur les changements apportés aux signaux sources pour recalculer tous les signaux enfants qui en dépendent. Dans l'approche \emph{pull}, c'est l'accès aux signaux enfants qui provoque le calcul des valeurs intermédiaires jusqu'aux signaux sources. Dans les deux cas, des opérations potentiellement inutiles ou redondantes sont effectuées.

L'approche mixte \emph{push-pull} se base sur une approche principalement \emph{pull} où l'accès à l'état d'un signal déclenche son évaluation, auquel vient s'ajouter un mécanisme de \emph{mémoïsation} qui maintient l'état courant du signal après son calcul. L'invalidation de ces caches se fait ensuite selon une approche \emph{push}: un changement d'état des signaux sources est notifié à toutes les dépendances de façon récursive.

\textit{Ajouter: schéma des événement internes au graphe: notification, invalidation, accès.}
