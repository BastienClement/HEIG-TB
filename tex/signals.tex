\chapter{Annexe: Signaux}

\section{Définition théorique}
	
	Un \code{Signal[T]} représente une information de type \code{T} dont la disponibilité ou la valeur peut varier avec le temps.
	À tout moment, un signal se trouve dans l'un des deux états suivants:
	\begin{enumerate}
		\item \code{Undefined}: le signal ne possède pas de valeur définie,
		\item \code{Defined(value)}: le signal possède actuellement la valeur \code{value}
	\end{enumerate}

	Il peut être vu comme une extension de \code{Future[T]}. De façon similaire, il représente la présence ou l'absence d'information au fil du temps, mais il est autorisé à changer d'état infiniment alors que l'état d'un \code{Future} est figé une fois celui-ci résolu.
	
	\code{Signal[T]} est covariant avec son paramètre de type \code{T}. L'interface exposée ne permettant que l'accès à la valeur du signal ou sa transformation par le biais de la construction d'un nouveau signal, une instance \code{Signal[B]} est substituable à \code{Signal[A]} si \code{B <: A}.
	
	L'état d'un signal peut être dépendant de l'état d'un ou plusieurs autres signaux. Il constitue alors un signal \emph{enfant} associé à un ensemble de signaux \emph{parents}. Cet ensemble peut varier dynamiquement en fonction de la valeur des ces signaux mais ne peut devenir nul. Un signal enfant ne peut changer d'état que lorsque au moins l'un des ses signaux parents change d'état.
	
	À l'inverse, un signal qui ne dépend d'aucun autre est appelé une \emph{source}. Le changement d'état d'un signal source ne peut s'opérer que par une mutation explicite, extérieur au système de signaux.
	
	La classification d'un signal en tant que signal source ou signal enfant est statique, il n'est pas autorisé pour un signal de transitionner d'une classe à l'autre après sa définition.
	
	Les signaux sont des constructions fonctionnelles semi-pures. Puisqu'ils encodent la notion de variabilité, ils sont naturellement dépendant du temps en tant qu'état global. Plus spécifiquement, ils dépendent d'un \emph{indice de génération} spécifique à ce signal désigné par $\gamma_s \in \Gamma_s$ qui est associé à chaque changement potentiel d'état du signal.
	
	Dans le cas d'un signal enfant, l'indice de génération est défini comme un $n$-uplet constitué des indices de générations de chaque signaux parents sur lesquels il est dépendant. De cette façon, l'indice et donc l'état des signaux parent est encodé dans l'indice du signal enfant et la dépendance vers d'autres signaux ne compromet pas sa pureté:
	\[
		\mathbb{D}^\gamma_{child} = \{ a, b, \dots \} \implies \Gamma_{child} = \Gamma_a \times \Gamma_b \times \dots
	\]
	avec $\mathbb{D}^\gamma_{a}$ l'ensemble des signaux envers lesquels $a$ est dépendant pour l'indice de génération \gamma. Par définition $|\mathbb{D}^\gamma_{a}| > 0 \iff a$ est un signal enfant.
	
	Dans le cas d'un signal source, l'indice de génération est une valeur abstraite et distincte pour chaque changement d'état.
	\[
		\mathbb{D}^\gamma_{source} = \emptyset \implies \forall \alpha \in \Gamma_{source}, \forall \beta \in Signals, (\alpha \notin \Gamma_\beta) \lor (\beta = source)
	\]
	Un signal peut alors être considéré comme une fonction pure $\Gamma_{sig} \to State_{[T]}$ associant à un indice de génération spécifique un état précis dont la valeur, si elle est définie, est de type $T$.
	\[
		sig(\gamma_{sig})\colon \Gamma_{sig} \to State_{[T]} = state \in \{ Undefined, Defined_{[T]}(value) \}
	\]
	Les changements d'état d'un signal sont des événements séquentiels. L'ensemble des indices de génération de ce signal forment ainsi un ensemble ordonné sur lequel il est possible de définir la fonction
	\begin{align*}
		\gamma^*_{sig} = prev(\gamma_{sig}) &\colon \Gamma_{sig} \to \Gamma_{sig}\\
		& = \begin{cases}
			\gamma^*_{sig} & \text{si }
				 \exists \gamma^*_{sig}, \forall \gamma^\alpha_{sig} < \gamma_{sig}, (\gamma^\alpha_{sig} \leq \gamma^*_{sig})\\
			\varnothing & \text{sinon}
		\end{cases}
	\end{align*}
	associant à chaque indice $\gamma_{sig}$ l'indice $\gamma^*_{sig}$ associé à l'état qui précédait immédiatement l'état associé à l'indice $\gamma_{sig}$. Cette propriété autorise un signal à être défini non seulement en fonction des états actuels d'autres signaux, mais aussi de leurs états antérieurs.
	
	\begin{figure}
		\begin{align*}
			hold (sig) &\colon Signal_{[T]} \to Signal_{[T]} \\
			           &\colon (\Gamma_{sig} \to State_{[T]}) \to \Gamma_{sig} \to State_{[T]} \\
			           &= \gamma \mapsto \begin{cases}
			           		sig(\gamma) & \text{si } sig(\gamma) \text{ est défini} \\
			           		hold(sig)(\gamma^*) & \text{sinon si } \gamma^* \ne \varnothing \\
			           		Undefined & \text{sinon}
			           \end{cases}
		\end{align*}
		\caption{Définition de la fonction $hold$}
		\label{fig:sig-hold}
	\end{figure}

	\begin{figure}
		\begin{lstlisting}
def hold[T](parent: Signal[T]): Signal[T] = {
	var previous: Option[T] = None
	Signal {
		val state = parent.option
		if (state.isDefined) previous = state
		state orElse previous
	}
}
		\end{lstlisting}
		\caption{Implémentation de la fonction $hold$}
		\label{fig:sig-hold-scala}
	\end{figure}

	La figure \ref{fig:sig-hold} présente la définition d'une fonction $hold$ exploitant ce mécanisme pour construire un signal enfant qui maintient sa valeur lorsque son parent devient indéfini.
	
	En pratique, le concept d'indice de génération est implicite. L'accès à un signal se fait toujours à partir de son état le plus récent et la disponibilité des états antérieurs est implémenté en utilisant des variables encapsulées dans le contexte de définition du signal. Les constructions ainsi formées ne sont donc pas strictement pures d'un point de vue fonctionnel mais sont compatible avec la notion théorique d'un signal et ne causent pas de surprise lors à l'usage. La figure \ref{fig:sig-hold-scala} présente une implémentation possible de la fonction $hold$ en Scala.
	
	En résumé, les fonctions utilisées pour définir ou transformer un signal doivent être \emph{semi-pures}:
	\begin{enumerate}
		\item elles ne peuvent dépendre d'aucun état implicite, hormis d'autres signaux et leurs états antérieurs, et
		\item elles ne doivent pas contenir d'effets de bords observables
	\end{enumerate}
	De cette façon, l'ordre d'évaluation des signaux ou même leur évaluation différée n'a pas d'importance dans le comportement du système. Ces propriétés ne sont pas vérifiables au niveau du langage, le développeur est ainsi responsable de s'assurer que ses fonctions soient conformes à ces contraintes.
	
	Le concept d'\emph{observateur} (Section \ref{sec:sig-obs}) est un mécanisme permettant d'introduire des effets de bords à partir de signaux, de façon sûre et définie.
	
	\texttt{Signal} vérifie les trois axiomes des monades\cite{haskell-monad-laws}:
	\begin{align*}
		Signal(x) \text{ flatMap } f &\equiv f(x) \\
		a \text{ flatMap } (x \mapsto Signal(x)) &\equiv a \\
		(a \text{ flatMap } f)  \text{ flatMap } g &\equiv
			a \text{ flatMap } (x \mapsto f(x)  \text{ flatMap } g) 
	\end{align*}
	Ils s'utilisent ainsi naturellement avec la compréhension \code{for .. yield} de Scala. Ici, l'opérateur $\equiv$ désigne une équivalence structurelle: les deux expressions sont substituables sans changer le comportement du programme.

\section{Opérations élémentaires}

	\subsection{Sélection (flatMap)}
	
		\begin{center}
			\code{def flatMap[U](f: T=>Signal[U]): Signal[U]}
		\end{center}
		
		\begin{align*}
			flatMap(a, f)
				&\colon (Signal_{[T]}, T \to Signal_{[U]}) \to Signal_{[U]} \\
				&\colon (\Gamma_a \to State_{[T]}, T \to \Gamma_f \to State_{[U]}) \to \Gamma_{a \times f} \to State_{[U]} \\
				&= \gamma \mapsto \begin{cases}
					f(v)(\gamma_f) & \text{si } a(\gamma_a) = Defined(v)\\
					Undefined & \text{sinon}\\
				\end{cases}
		\end{align*}
	
	\subsection{Application (map)}
		
		\begin{center}
			\code{def map[U](f: T=>U): Signal[U]}
		\end{center}
		
		Elle se définit comme une application particulière de \texttt{flatMap}:
		\begin{align*}
			map(a, f)
				&\colon (Signal_{[T]}, T \to U) \to Signal_{[U]} \\
				&\colon (\Gamma_a \to State_{[T]}, T \to U) \to \Gamma_a \to State_{[U]} \\
				&= flatMap \big( a, v \mapsto \gamma \mapsto Defined(f(v)) \big)\\
				&= \gamma \mapsto \begin{cases}
					Defined \big(f (v) \big) & \text{si } a(\gamma) = Defined(v)\\
					Undefined & \text{sinon}\\
				\end{cases}
		\end{align*}
	
	\subsection{Filtrage (filter)}
	
		La fonction \texttt{filter} effectue une opération de filtrage d'un signal en appliquant un prédicat \texttt{p} à la valeur courante du signal et retournant un nouveau signal de même valeur si le prédicat est vérifié, ou un signal indéfini si le prédicat n'est pas vérifié.
	
		\begin{center}
			\code{def filter(p: T=>Boolean): Signal[T]}
		\end{center}
		
		Elle se définit également comme une application particulière de \texttt{flatMap}:
		\begin{align*}
			filter(a, p)
				&\colon (Signal_{[T]}, T \to Boolean) \to Signal_{[T]} \\
				&\colon (\Gamma_a \to State_{[T]}, T \to Boolean) \to \Gamma_a \to State_{[T]} \\
				&= flatMap \left( a, v \mapsto \gamma \mapsto \begin{cases}
					a(\gamma) & \text{si } p(v)\\
					Undefined & \text{sinon}\\
				\end{cases} \right)\\
				&= \gamma \mapsto \begin{cases}
					a(\gamma) & \text{si } a(\gamma) = Defined(v) \text{ et } p(v)\\
					Undefined & \text{sinon}\\
				\end{cases}
		\end{align*}
		
	\subsection{Lecture}
	
		\begin{center}
			\code{def option: Option[T]}\\
			\code{def value: T}\\
		\end{center}
	
		Permet l'accès à la valeur actuelle d'un signal.
		\[
			a.option = \begin{cases}
				Some(a.value) & \text{si } a \text{ est défini}\\
				None & \text{si } a \text{ est indéfini}
			\end{cases}
		\]
		\[
			a.value = \left(opt \mapsto \begin{cases}
				value & \text{si } opt \text{ est } Some(value)\\
				Nothing & \text{si } opt \text{ est } None
			\end{cases}\right) \circ a.option
		\]
