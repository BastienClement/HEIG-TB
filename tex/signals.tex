\chapter{Signaux}

\section{Introduction}

	La construction d'interfaces utilisateur met en évidence la problématique de la gestion des interactions et du maintient de la cohérence des informations présentées. En effet, les actions effectuées par l'utilisateur modifient l'état du logiciel et requièrent alors une actualisation de l'affichage. Lorsque l'interface devient complexe, maintenir une cohérence globale présente une difficulté de plus en plus importante. Le problème est exacerbé lorsque les modifications de l'état ne proviennent pas uniquement de l'utilisateur mais peuvent également survenir par l'action de processus asynchrones tel qu'une tâche de fond ou une connexion réseau.
	
	La séparation classique Modèle-Vue-Contrôleur repose généralement la notion d'\emph{Observable} et d'\emph{Observateur} pour lier Vue et Modèle. Ce concept présente cependant de multiples inconvénients tel que la promotion d'effets de bord, une diminution de l'encapsulation, une verbosité excessive; le rendant ainsi fastidieux à l'utilisation et sujet à erreurs\cite{odersky2012}.
	
	Ingo Maier et Martin Odersky proposent ainsi une approche plus fonctionnelle et composable avec la bibliothèque \emph{Scala.React}\cite{scala-react} avec entre autres la notion de signal: une valeur pouvant varier avec le temps. Cependant les signaux ne sont qu'un des multiples outils mis à disposition et l'utilisation de la bibliothèque se révèle être excessivement complexe, même dans les cas les plus simples\cite[\small Related~Work]{scala.rx}.
	
	Partant de ce constat, Li Haoyi a ainsi développé \emph{Scala.Rx}\cite{scala.rx}: une réimplémentation simplifiée du concept de signaux avec une emphase sur la simplicité, à la fois au niveau de la conception que de l'utilisation. Cependant, par simplicité, plusieurs limitations ont été volontairement imposées et se révèlent être particulièrement gênantes dans le cadre de ce projet.
	
	Xuen implémente ainsi un concept de signaux largement basés sur ceux de \emph{Scala.Rx}, mais dont les fonctionnalités ont été spécifiquement adaptées à leurs utilisation dans le cadre du développement d'interfaces utilisateur.

\section{Définition théorique}
	
	Un \code{Signal[T]} représente une information de type \code{T} dont la disponibilité ou la valeur peut varier avec le temps.
	À tout moment, un signal se trouve dans l'un des deux états suivants:
	\begin{enumerate}
		\item \code{Undefined}: le signal ne possède pas de valeur définie,
		\item \code{Defined(value)}: le signal possède actuellement la valeur \code{value}
	\end{enumerate}

	Il peut être vu comme une extension de \code{Future[T]}. De façon similaire, il représente la présence ou l'absence d'information au fil du temps, mais il est autorisé à changer d'état infiniment alors que l'état d'un \code{Future} est figé une fois celui-ci résolu.
	
	\code{Signal[T]} est covariant avec son paramètre de type \code{T}. L'interface exposée ne permettant que l'accès à la valeur du signal ou sa transformation par le biais de la construction d'un nouveau signal, une instance \code{Signal[B]} est substituable à \code{Signal[A]} si \code{B <: A}.
	
	L'état d'un signal peut être dépendant de l'état d'un ou plusieurs autres signaux. Il constitue alors un signal \emph{enfant} associé à un ensemble de signaux \emph{parents}. Cet ensemble peut varier dynamiquement en fonction de la valeur des ces signaux mais ne peut devenir nul. Un signal enfant ne peut changer d'état que lorsque au moins l'un des ses signaux parents change d'état.
	
	À l'inverse, un signal qui ne dépend d'aucun autre est appelé une \emph{source}. Le changement d'état d'un signal source ne peut s'opérer que par une mutation explicite, extérieur au système de signaux.
	
	La classification d'un signal en tant que signal source ou signal enfant est statique, il n'est pas autorisé pour un signal de transitionner d'une classe à l'autre après sa définition.
	
	Les signaux sont des constructions fonctionnelles semi-pures. Puisqu'ils encodent la notion de variabilité, ils sont naturellement dépendant du temps en tant qu'état global. Plus spécifiquement, ils dépendent d'un \emph{indice de génération} spécifique à ce signal désigné par $\gamma_s \in \Gamma_s$ qui est associé à chaque changement potentiel d'état du signal.
	
	Dans le cas d'un signal enfant, l'indice de génération est défini comme un $n$-uplet constitué des indices de générations de chaque signaux parents sur lesquels il est dépendant. De cette façon, l'indice et donc l'état des signaux parent est encodé dans l'indice du signal enfant et la dépendance vers d'autres signaux ne compromet pas sa pureté:
	\[
		\mathbb{D}^\gamma_{child} = \{ a, b, \dots \} \implies \Gamma_{child} = \Gamma_a \times \Gamma_b \times \dots
	\]
	avec $\mathbb{D}^\gamma_{a}$ l'ensemble des signaux envers lesquels $a$ est dépendant pour l'indice de génération \gamma. Par définition $|\mathbb{D}^\gamma_{a}| > 0 \iff a$ est un signal enfant.
	
	Dans le cas d'un signal source, l'indice de génération est une valeur abstraite et distincte pour chaque changement d'état.
	\[
		\mathbb{D}^\gamma_{source} = \emptyset \implies \forall \alpha \in \Gamma_{source}, \forall \beta \in Signals, (\alpha \notin \Gamma_\beta) \lor (\beta = source)
	\]
	Un signal peut alors être considéré comme une fonction pure $\Gamma_{sig} \to State_{[T]}$ associant à un indice de génération spécifique un état précis dont la valeur, si elle est définie, est de type $T$.
	\[
		sig(\gamma_{sig})\colon \Gamma_{sig} \to State_{[T]} = state \in \{ Undefined, Defined_{[T]}(value) \}
	\]
	Les changements d'état d'un signal sont des événements séquentiels. L'ensemble des indices de génération de ce signal forment ainsi un ensemble ordonné sur lequel il est possible de définir la fonction
	\begin{align*}
		\gamma^*_{sig} = prev(\gamma_{sig}) &\colon \Gamma_{sig} \to \Gamma_{sig}\\
		& = \begin{cases}
			\gamma^*_{sig} & \text{si }
				 \exists \gamma^*_{sig}, \forall \gamma^\alpha_{sig} < \gamma_{sig}, (\gamma^\alpha_{sig} \leq \gamma^*_{sig})\\
			\varnothing & \text{sinon}
		\end{cases}
	\end{align*}
	associant à chaque indice $\gamma_{sig}$ l'indice $\gamma^*_{sig}$ associé à l'état qui précédait immédiatement l'état associé à l'indice $\gamma_{sig}$. Cette propriété autorise un signal à être défini non seulement en fonction des états actuels d'autres signaux, mais aussi de leurs états antérieurs.
	
	\begin{figure}
		\begin{align*}
			hold (sig) &\colon Signal_{[T]} \to Signal_{[T]} \\
			           &\colon (\Gamma_{sig} \to State_{[T]}) \to \Gamma_{sig} \to State_{[T]} \\
			           &= \gamma \mapsto \begin{cases}
			           		sig(\gamma) & \text{si } sig(\gamma) \text{ est défini} \\
			           		hold(sig)(\gamma^*) & \text{sinon si } \gamma^* \ne \varnothing \\
			           		Undefined & \text{sinon}
			           \end{cases}
		\end{align*}
		\caption{Définition de la fonction $hold$}
		\label{fig:sig-hold}
	\end{figure}

	\begin{figure}
		\begin{lstlisting}
def hold[T](parent: Signal[T]): Signal[T] = {
	var previous: Option[T] = None
	Signal {
		val state = parent.option
		if (state.isDefined) previous = state
		state orElse previous
	}
}
		\end{lstlisting}
		\caption{Implémentation de la fonction $hold$}
		\label{fig:sig-hold-scala}
	\end{figure}

	La figure \ref{fig:sig-hold} présente la définition d'une fonction $hold$ exploitant ce mécanisme pour construire un signal enfant qui maintient sa valeur lorsque son parent devient indéfini.
	
	En pratique, le concept d'indice de génération est implicite. L'accès à un signal se fait toujours à partir de son état le plus récent et la disponibilité des états antérieurs est implémenté en utilisant des variables encapsulées dans le contexte de définition du signal. Les constructions ainsi formées ne sont donc pas strictement pures d'un point de vue fonctionnel mais sont compatible avec la notion théorique d'un signal et ne causent pas de surprise lors à l'usage. La figure \ref{fig:sig-hold-scala} présente une implémentation possible de la fonction $hold$ en Scala.
	
	En résumé, les fonctions utilisées pour définir ou transformer un signal doivent être \emph{semi-pures}:
	\begin{enumerate}
		\item elles ne peuvent dépendre d'aucun état implicite, hormis d'autres signaux et leurs états antérieurs, et
		\item elles ne doivent pas contenir d'effets de bords observables
	\end{enumerate}
	De cette façon, l'ordre d'évaluation des signaux ou même leur évaluation différée n'a pas d'importance dans le comportement du système. Ces propriétés ne sont pas vérifiables au niveau du langage, le développeur est ainsi responsable de s'assurer que ses fonctions soient conformes à ces contraintes.
	
	Le concept d'\emph{observateur} (Section \ref{sec:sig-obs}) est un mécanisme permettant d'introduire des effets de bords à partir de signaux, de façon sûre et définie.
	
	\texttt{Signal} vérifie les trois axiomes des monades\cite{haskell-monad-laws}:
	\begin{align*}
		Signal(x) \text{ flatMap } f &\equiv f(x) \\
		a \text{ flatMap } (x \mapsto Signal(x)) &\equiv a \\
		(a \text{ flatMap } f)  \text{ flatMap } g &\equiv
			a \text{ flatMap } (x \mapsto f(x)  \text{ flatMap } g) 
	\end{align*}
	Ils s'utilisent ainsi naturellement avec la compréhension \code{for .. yield} de Scala. Ici, l'opérateur $\equiv$ désigne une équivalence structurelle: les deux expressions sont substituables sans changer le comportement du programme.

\section{Opérations élémentaires}
	
	\subsection{Construction}
	
		Trois constructeurs sont définis pour former un signal.
	
		\begin{center}
			\code{def apply[T](expr: => T): Signal[T]}
			\code{def wrap[T](value: T): Constant[T]}
			\code{def define[T](expr: => Option[T]): Signal[T]}
		\end{center}

	\subsection{Sélection (flatMap)}
	
		La fonction \texttt{flatMap} est la fonction universelle de transformation des monades. Elle est suffisamment générale pour permettre de définir toutes les autres fonctions de transformation comme des cas particuliers de \texttt{flatMap}.
	
		\begin{center}
			\code{def flatMap[U](f: T=>Signal[U]): Signal[U]}
		\end{center}
		
		Fondamentalement, \texttt{flatMap} implémente une opération de sélection: étant donné un signal \texttt{a} de type \texttt{Signal[T]} et une fonction \texttt{f: T => Signal[U]}, la fonction \texttt{f} est appliquée à la valeur actuelle du signal \texttt{a} afin d'obtenir un second signal \texttt{b} de type \texttt{Signal[U]} et retourne un troisième signal \texttt{c} également de type \texttt{Signal[U]} dont la valeur est en tout temps égale à celle du signal \texttt{b}.
		
		Si le signal \texttt{a} est indéfini, la fonction \texttt{f} n'est pas appliquée et le signal \texttt{c} est également considéré indéfini.
		\begin{align*}
			flatMap(a, f)
				&\colon (Signal_{[T]}, T \to Signal_{[U]}) \to Signal_{[U]} \\
				&\colon (\Gamma_a \to State_{[T]}, T \to \Gamma_f \to State_{[U]}) \to \Gamma_{a \times f} \to State_{[U]} \\
				&= \gamma \mapsto \begin{cases}
					f(v)(\gamma_f) & \text{si } a(\gamma_a) = Defined(v)\\
					Undefined & \text{sinon}\\
				\end{cases}
		\end{align*}
	
	\subsection{Application (map)}
	
		La fonction \texttt{map} effectue une opération de transformation sur la valeur d'un signal en appliquant la fonction \texttt{f} à la valeur courante du signal et retournant un nouveau signal représentant le résultat de cette transformation.
		
		\begin{center}
			\code{def map[U](f: T=>U): Signal[U]}
		\end{center}
		
		Elle se définit comme une application particulière de \texttt{flatMap}:
		\begin{align*}
			map(a, f)
				&\colon (Signal_{[T]}, T \to U) \to Signal_{[U]} \\
				&\colon (\Gamma_a \to State_{[T]}, T \to U) \to \Gamma_a \to State_{[U]} \\
				&= flatMap \big( a, v \mapsto \gamma \mapsto Defined(f(v)) \big)\\
				&= \gamma \mapsto \begin{cases}
					Defined \big(f (v) \big) & \text{si } a(\gamma) = Defined(v)\\
					Undefined & \text{sinon}\\
				\end{cases}
		\end{align*}
	
	\subsection{Filtrage (filter)}
	
		La fonction \texttt{filter} effectue une opération de filtrage d'un signal en appliquant un prédicat \texttt{p} à la valeur courante du signal et retournant un nouveau signal de même valeur si le prédicat est vérifié, ou un signal indéfini si le prédicat n'est pas vérifié.
	
		\begin{center}
			\code{def filter(p: T=>Boolean): Signal[T]}
		\end{center}
		
		Elle se définit également comme une application particulière de \texttt{flatMap}:
		\begin{align*}
			filter(a, p)
				&\colon (Signal_{[T]}, T \to Boolean) \to Signal_{[T]} \\
				&\colon (\Gamma_a \to State_{[T]}, T \to Boolean) \to \Gamma_a \to State_{[T]} \\
				&= flatMap \left( a, v \mapsto \gamma \mapsto \begin{cases}
					a(\gamma) & \text{si } p(v)\\
					Undefined & \text{sinon}\\
				\end{cases} \right)\\
				&= \gamma \mapsto \begin{cases}
					a(\gamma) & \text{si } a(\gamma) = Defined(v) \text{ et } p(v)\\
					Undefined & \text{sinon}\\
				\end{cases}
		\end{align*}
		
	\subsection{Lecture}
	
		\begin{center}
			\code{def option: Option[T]}\\
			\code{def value: T}\\
		\end{center}
	
		Permet l'accès à la valeur actuelle d'un signal.
		\[
			a.option = \begin{cases}
				Some(a.value) & \text{si } a \text{ est défini}\\
				None & \text{si } a \text{ est indéfini}
			\end{cases}
		\]
		\[
			a.value = \left(opt \mapsto \begin{cases}
				value & \text{si } opt \text{ est } Some(value)\\
				Nothing & \text{si } opt \text{ est } None
			\end{cases}\right) \circ a.option
		\]

\section{Expression}

	Une méthode alternative de définition des signaux sont les expressions. L'objectif ici est d'utiliser les mécanismes du langage Scala pour permettre une détection automatique des dépendances entres signaux.
	\begin{lstlisting}
val e = Signal {
	if (c.value > 5) a.value + b.value
	else a.value + d.value
}
	\end{lstlisting}
	Dans cet exemple, le signal \texttt{e} est déclaré comme la somme des signaux \texttt{a} et \texttt{b} si la valeur du signal \texttt{c} est supérieur à 5, ou comme la somme de \texttt{a} et \texttt{d} dans le cas contraire. Il n'est pas nécessaire de déclarer explicitement ces dépendances ou d'utiliser les opérations monadiques pour combiner ces différents signaux. L'accès à l'état d'un autre signal à l'intérieur de l'expression de définition est suffisant pour détecter la dépendance entre les deux signaux et assurer la propagation des changements.
	
	Cette approche est un outil très efficace pour combiner de façon complexe de multiples signaux. Seuls les signaux réellement utilisés lors du calcul de la valeur courante du signal sont utilisés comme dépendances. Par exemple, le signal \texttt{d} ne sera pas une dépendance de \texttt{e} si \texttt{c} est supérieur à 5. De cette façon, le signal ne dépend que des informations qu'il a réellement utilisé pour générer son état et n'est pas recalculé inutilement.
	
	L'accès à la valeur d'un signal indéfini dans une expression de définition provoque le lancement d'une exception particulière qui interrompt le calcul de la valeur du signal et indique à l'implémentation que l'état du signal enfant doit également être indéfini. Il n'est donc pas nécessaire de vérifier systématiquement que la valeur du signal soit définie. Le code est ainsi écrit de façon optimiste, laissant à l'implémentation des signaux le soin de gérer le cas non-défini.

\section{Propagation push-pull}

	Deux modes de fonctionnement sont généralement décrit pour des systèmes fonctionnels-réactifs: \emph{push} et \emph{pull}.
	
	L'approche \emph{push} se base sur les changements apportés aux signaux sources pour recalculer tous les signaux enfants qui en dépendent. Dans l'approche \emph{pull}, c'est l'accès aux signaux enfants qui provoque le calcul des valeurs intermédiaires jusqu'aux signaux sources. Dans les deux cas, des opérations potentiellement inutiles ou redondantes sont effectuées.
	
	L'approche mixte \emph{push-pull} se base sur une approche principalement \emph{pull} où l'accès à l'état d'un signal déclenche son évaluation, auquel vient s'ajouter un mécanisme de \emph{mémoïsation} qui maintient l'état courant du signal après son calcul. L'invalidation de ces caches se fait ensuite selon une approche \emph{push}: un changement d'état des signaux sources est notifié à toutes les dépendance.

\section{Observateurs} \label{sec:sig-obs}

	Un observateur permet d'ajouter des effets de bords aux changements d'états d'un signal.

\section{Comparaison avec les solutions existantes}

	\subsection{ReactiveX}
	
	\emph{ReactiveX} est une \og API pour la programmation asynchrone basée sur des flux observables \fg. Un cas d'utilisation de l'API sont par exemple le concept d'\texttt{Observable} disponible dans le framework Angular~2. Cependant, les flux d'événements de ReactiveX sont fondamentalement différents du concept de signaux: un signal est une valeur qui varie avec le temps tandis qu'un observable est une source d'événements discrets et sans rémanence.
	
	Dans le cas des signaux, le style de programmation encouragé est un style fonctionnel et déclaratif: le développeur exprime \emph{comment} de multiples valeurs doivent être assemblées pour former le résultat attendu, sans se soucier du timing des opérations puisque l'ensemble est considéré comme un système pseudo-continu.
	
	Les observable en revanche mettent au premier plan la séquence d'événements générés et par extension la gestion du temps. Le système est approché comme une série d'événements discrets plutôt que comme une valeur continue.
	
	
		
	\subsection{Reactive-Web}
	
	TODO
	
	\subsection{Scala.rx}
	
	Scala.rx est l'implémentation la plus proche des signaux utilisés dans ce projet. La simplicité d'utilisation est particulièrement appréciable avec la méthode de définition de \texttt{Rx}s sur la base d'expressions arbitraires.
	
	Les différences sont principalement liées aux limitations volontairement imposées dans Scala.rx.
	
	\subsubsection{Pas de variable réactive non-définie / vide}
	
	La raison invoquée est la difficulté d'intégrer l'absence de valeur de façon intuitive dans la syntaxe déclarative. Plus spécifiquement, l'auteur mentionne plusieurs solutions potentiels:
	\begin{enumerate}
		\item Bloquer le thread courant jusqu'à ce qu'une valeur soit disponible. Cette solution n'est cependant pas envisageable pour une implémentation visant l'environnement Javascript.
		\item Lancer une exception lors de l'accès à une variable vide, mais recommencer l'opération une fois que sa valeur sera définie. Cette option présente le désavantages que le calcul d'une variable réactive puisse potentiellement être démarré puis interrompu de multiples fois si de nombreuses dépendances sont indéfinies.
		\item Obliger le style monadique et retirer la méthode implicite de définition. Cette option n'est pas considérée pour des raisons d'expérience utilisateur évidentes.
		\item Utiliser un plugin du compilateur pour transformer automatiquement le code en style monadique. Cette approche présente cependant de nombreux défis techniques et requiert une étape supplémentaire de configuration indésirable.
	\end{enumerate}

	En pratique l'absence de variable réactive vide est une gêne considérable dans le domaine du web où toutes les opérations sont asynchrones et non-bloquante. Le concept de promesse est omni-présent et il est ainsi difficile d'associer les interfaces natives du navigateur avec le réseau de variables réactives.
	
	Une première approche est d'utiliser directement le type \texttt{Option} de Scala pour exprimer l'absence d'information le temps de l'opération. Mais cette idée impose une verbosité beaucoup plus importante du code puisqu'il est maintenant nécessaire de manipuler explicitement des \texttt{Rx[Option[T]]} au lieu de simples \texttt{Rx[T]} et de laisser le soin de la gestion de l'asynchrone à la bibliothèque.
	
	De plus, la seconde approche proposée (interrompre le calcul par une exception) ne semble pas déraisonnable et peut constituer une approche valide si correctement documentée. Il est important que les conséquences d'une variable indéfinie soient connues et considérées, mais leur absence volontaire semble au final plus gênante que bénéfique. Par ailleurs, le style monadique ne présente pas les inconvénients mentionnés et constitue une alternative valide si le style est plus adapté à un problème spécifique.
	
	\subsubsection{Complexité d'implémentation}
	
	Malgré l'effort fourni pour proposer une interface simple et efficace, l'implémentation est en réalité relativement complexe et très largement basée sur l'utilisation de macros. Le code écrit par le développeur n'est pas le code finalement exécuté. Une raison probable de cette implémentation est basée sur la méthode choisie pour détecter automatiquement les dépendances entre variables réactives avec le style déclaratif.
	
	Dans Scala.rx, les expressions qui définissent des variables réactives sont réécrite sous formes de fonctions exploitant largement le système de paramètres implicites pour transmettre le contexte d'accès à une variable réactive entre parent et enfant. Bien que cela soit une approche très proche des standards en Scala, elle requiert une couche syntaxique supplémentaire ou l'utilisation de macros afin de l'ajouter automatiquement. Le système résultant est excessivement complexe et les erreurs rencontrées lors de l'usage ne sont pas intuitives puisqu'elles ne correspondent pas au code écrit. 
	
	De plus, l'approche n'est pas portable entre les versions de Scala puisqu'elle dépend de l'implémentation interne du compilateur. Dans le cas de Scala.rx, l'implémentation est compilée simultanément pour les version 2.10, 2.11 et 2.12 de Scala et requiert pour chaque version une implémentation différente des macros pour s'aligner avec les changements apportés au compilateur et à la syntaxe du langage.
	
	Une approche alternative est possible: \texttt{DynamicVariable}. Cette classe de la bibliothèque standard de Scala est rarement utilisée puisque très spécifique et généralement moins explicite que l'usage de paramètres implicites qui sont plus en accord avec les principes de la programmation fonctionnelle. Elle rempli cependant un rôle semblable en offrant une sémantique de variable à portée dynamique plutôt que lexicale. Ce mécanisme permet de déplacer la transmission du contexte d'évaluation des paramètres implicites à un canal annexe dédié.
	
	Le code est ainsi fortement simplifié puisque la transmission du contexte est clairement dissociée, évitant la nécessité de modifier le code utilisateur et donc l'usage de macros au prix d'une architecture pouvant être considérée moins pure d'un point de vue fonctionnel. L'absence de macros permet également une compatibilité plus aisée avec les futures versions du langage.
	
	\subsubsection{Évaluation stricte}
	
	TODO